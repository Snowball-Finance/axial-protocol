    // Sources flattened with hardhat v2.6.7 https://hardhat.org

    // File @openzeppelin/contracts/utils/Context.sol@v3.4.2

    // SPDX-License-Identifier: MIT

    pragma solidity >=0.6.0 <0.8.0;

    /*
    * @dev Provides information about the current execution context, including the
    * sender of the transaction and its data. While these are generally available
    * via msg.sender and msg.data, they should not be accessed in such a direct
    * manner, since when dealing with GSN meta-transactions the account sending and
    * paying for execution may not be the actual sender (as far as an application
    * is concerned).
    *
    * This contract is only required for intermediate, library-like contracts.
    */
    abstract contract Context {
        function _msgSender() internal view virtual returns (address payable) {
            return msg.sender;
        }

        function _msgData() internal view virtual returns (bytes memory) {
            this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
            return msg.data;
        }
    }


    // File @openzeppelin/contracts/access/Ownable.sol@v3.4.2


    pragma solidity >=0.6.0 <0.8.0;

    /**
    * @dev Contract module which provides a basic access control mechanism, where
    * there is an account (an owner) that can be granted exclusive access to
    * specific functions.
    *
    * By default, the owner account will be the one that deploys the contract. This
    * can later be changed with {transferOwnership}.
    *
    * This module is used through inheritance. It will make available the modifier
    * `onlyOwner`, which can be applied to your functions to restrict their use to
    * the owner.
    */
    abstract contract Ownable is Context {
        address private _owner;

        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

        /**
        * @dev Initializes the contract setting the deployer as the initial owner.
        */
        constructor () internal {
            address msgSender = _msgSender();
            _owner = msgSender;
            emit OwnershipTransferred(address(0), msgSender);
        }

        /**
        * @dev Returns the address of the current owner.
        */
        function owner() public view virtual returns (address) {
            return _owner;
        }

        /**
        * @dev Throws if called by any account other than the owner.
        */
        modifier onlyOwner() {
            require(owner() == _msgSender(), "Ownable: caller is not the owner");
            _;
        }

        /**
        * @dev Leaves the contract without owner. It will not be possible to call
        * `onlyOwner` functions anymore. Can only be called by the current owner.
        *
        * NOTE: Renouncing ownership will leave the contract without an owner,
        * thereby removing any functionality that is only available to the owner.
        */
        function renounceOwnership() public virtual onlyOwner {
            emit OwnershipTransferred(_owner, address(0));
            _owner = address(0);
        }

        /**
        * @dev Transfers ownership of the contract to a new account (`newOwner`).
        * Can only be called by the current owner.
        */
        function transferOwnership(address newOwner) public virtual onlyOwner {
            require(newOwner != address(0), "Ownable: new owner is the zero address");
            emit OwnershipTransferred(_owner, newOwner);
            _owner = newOwner;
        }
    }


    // File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2


    pragma solidity >=0.6.0 <0.8.0;

    /**
    * @dev Wrappers over Solidity's arithmetic operations with added overflow
    * checks.
    *
    * Arithmetic operations in Solidity wrap on overflow. This can easily result
    * in bugs, because programmers usually assume that an overflow raises an
    * error, which is the standard behavior in high level programming languages.
    * `SafeMath` restores this intuition by reverting the transaction when an
    * operation overflows.
    *
    * Using this library instead of the unchecked operations eliminates an entire
    * class of bugs, so it's recommended to use it always.
    */
    library SafeMath {
        /**
        * @dev Returns the addition of two unsigned integers, with an overflow flag.
        *
        * _Available since v3.4._
        */
        function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }

        /**
        * @dev Returns the substraction of two unsigned integers, with an overflow flag.
        *
        * _Available since v3.4._
        */
        function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
            if (b > a) return (false, 0);
            return (true, a - b);
        }

        /**
        * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
        *
        * _Available since v3.4._
        */
        function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }

        /**
        * @dev Returns the division of two unsigned integers, with a division by zero flag.
        *
        * _Available since v3.4._
        */
        function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }

        /**
        * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
        *
        * _Available since v3.4._
        */
        function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }

        /**
        * @dev Returns the addition of two unsigned integers, reverting on
        * overflow.
        *
        * Counterpart to Solidity's `+` operator.
        *
        * Requirements:
        *
        * - Addition cannot overflow.
        */
        function add(uint256 a, uint256 b) internal pure returns (uint256) {
            uint256 c = a + b;
            require(c >= a, "SafeMath: addition overflow");
            return c;
        }

        /**
        * @dev Returns the subtraction of two unsigned integers, reverting on
        * overflow (when the result is negative).
        *
        * Counterpart to Solidity's `-` operator.
        *
        * Requirements:
        *
        * - Subtraction cannot overflow.
        */
        function sub(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b <= a, "SafeMath: subtraction overflow");
            return a - b;
        }

        /**
        * @dev Returns the multiplication of two unsigned integers, reverting on
        * overflow.
        *
        * Counterpart to Solidity's `*` operator.
        *
        * Requirements:
        *
        * - Multiplication cannot overflow.
        */
        function mul(uint256 a, uint256 b) internal pure returns (uint256) {
            if (a == 0) return 0;
            uint256 c = a * b;
            require(c / a == b, "SafeMath: multiplication overflow");
            return c;
        }

        /**
        * @dev Returns the integer division of two unsigned integers, reverting on
        * division by zero. The result is rounded towards zero.
        *
        * Counterpart to Solidity's `/` operator. Note: this function uses a
        * `revert` opcode (which leaves remaining gas untouched) while Solidity
        * uses an invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function div(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, "SafeMath: division by zero");
            return a / b;
        }

        /**
        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
        * reverting when dividing by zero.
        *
        * Counterpart to Solidity's `%` operator. This function uses a `revert`
        * opcode (which leaves remaining gas untouched) while Solidity uses an
        * invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function mod(uint256 a, uint256 b) internal pure returns (uint256) {
            require(b > 0, "SafeMath: modulo by zero");
            return a % b;
        }

        /**
        * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
        * overflow (when the result is negative).
        *
        * CAUTION: This function is deprecated because it requires allocating memory for the error
        * message unnecessarily. For custom revert reasons use {trySub}.
        *
        * Counterpart to Solidity's `-` operator.
        *
        * Requirements:
        *
        * - Subtraction cannot overflow.
        */
        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b <= a, errorMessage);
            return a - b;
        }

        /**
        * @dev Returns the integer division of two unsigned integers, reverting with custom message on
        * division by zero. The result is rounded towards zero.
        *
        * CAUTION: This function is deprecated because it requires allocating memory for the error
        * message unnecessarily. For custom revert reasons use {tryDiv}.
        *
        * Counterpart to Solidity's `/` operator. Note: this function uses a
        * `revert` opcode (which leaves remaining gas untouched) while Solidity
        * uses an invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b > 0, errorMessage);
            return a / b;
        }

        /**
        * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
        * reverting with custom message when dividing by zero.
        *
        * CAUTION: This function is deprecated because it requires allocating memory for the error
        * message unnecessarily. For custom revert reasons use {tryMod}.
        *
        * Counterpart to Solidity's `%` operator. This function uses a `revert`
        * opcode (which leaves remaining gas untouched) while Solidity uses an
        * invalid opcode to revert (consuming all remaining gas).
        *
        * Requirements:
        *
        * - The divisor cannot be zero.
        */
        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
            require(b > 0, errorMessage);
            return a % b;
        }
    }


    // File @openzeppelin/contracts/utils/EnumerableSet.sol@v3.4.2


    pragma solidity >=0.6.0 <0.8.0;

    /**
    * @dev Library for managing
    * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
    * types.
    *
    * Sets have the following properties:
    *
    * - Elements are added, removed, and checked for existence in constant time
    * (O(1)).
    * - Elements are enumerated in O(n). No guarantees are made on the ordering.
    *
    * ```
    * contract Example {
    *     // Add the library methods
    *     using EnumerableSet for EnumerableSet.AddressSet;
    *
    *     // Declare a set state variable
    *     EnumerableSet.AddressSet private mySet;
    * }
    * ```
    *
    * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
    * and `uint256` (`UintSet`) are supported.
    */
    library EnumerableSet {
        // To implement this library for multiple types with as little code
        // repetition as possible, we write it in terms of a generic Set type with
        // bytes32 values.
        // The Set implementation uses private functions, and user-facing
        // implementations (such as AddressSet) are just wrappers around the
        // underlying Set.
        // This means that we can only create new EnumerableSets for types that fit
        // in bytes32.

        struct Set {
            // Storage of set values
            bytes32[] _values;

            // Position of the value in the `values` array, plus 1 because index 0
            // means a value is not in the set.
            mapping (bytes32 => uint256) _indexes;
        }

        /**
        * @dev Add a value to a set. O(1).
        *
        * Returns true if the value was added to the set, that is if it was not
        * already present.
        */
        function _add(Set storage set, bytes32 value) private returns (bool) {
            if (!_contains(set, value)) {
                set._values.push(value);
                // The value is stored at length-1, but we add 1 to all indexes
                // and use 0 as a sentinel value
                set._indexes[value] = set._values.length;
                return true;
            } else {
                return false;
            }
        }

        /**
        * @dev Removes a value from a set. O(1).
        *
        * Returns true if the value was removed from the set, that is if it was
        * present.
        */
        function _remove(Set storage set, bytes32 value) private returns (bool) {
            // We read and store the value's index to prevent multiple reads from the same storage slot
            uint256 valueIndex = set._indexes[value];

            if (valueIndex != 0) { // Equivalent to contains(set, value)
                // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
                // the array, and then remove the last element (sometimes called as 'swap and pop').
                // This modifies the order of the array, as noted in {at}.

                uint256 toDeleteIndex = valueIndex - 1;
                uint256 lastIndex = set._values.length - 1;

                // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs
                // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.

                bytes32 lastvalue = set._values[lastIndex];

                // Move the last value to the index where the value to delete is
                set._values[toDeleteIndex] = lastvalue;
                // Update the index for the moved value
                set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based

                // Delete the slot where the moved value was stored
                set._values.pop();

                // Delete the index for the deleted slot
                delete set._indexes[value];

                return true;
            } else {
                return false;
            }
        }

        /**
        * @dev Returns true if the value is in the set. O(1).
        */
        function _contains(Set storage set, bytes32 value) private view returns (bool) {
            return set._indexes[value] != 0;
        }

        /**
        * @dev Returns the number of values on the set. O(1).
        */
        function _length(Set storage set) private view returns (uint256) {
            return set._values.length;
        }

    /**
        * @dev Returns the value stored at position `index` in the set. O(1).
        *
        * Note that there are no guarantees on the ordering of values inside the
        * array, and it may change when more values are added or removed.
        *
        * Requirements:
        *
        * - `index` must be strictly less than {length}.
        */
        function _at(Set storage set, uint256 index) private view returns (bytes32) {
            require(set._values.length > index, "EnumerableSet: index out of bounds");
            return set._values[index];
        }

        // Bytes32Set

        struct Bytes32Set {
            Set _inner;
        }

        /**
        * @dev Add a value to a set. O(1).
        *
        * Returns true if the value was added to the set, that is if it was not
        * already present.
        */
        function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
            return _add(set._inner, value);
        }

        /**
        * @dev Removes a value from a set. O(1).
        *
        * Returns true if the value was removed from the set, that is if it was
        * present.
        */
        function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
            return _remove(set._inner, value);
        }

        /**
        * @dev Returns true if the value is in the set. O(1).
        */
        function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
            return _contains(set._inner, value);
        }

        /**
        * @dev Returns the number of values in the set. O(1).
        */
        function length(Bytes32Set storage set) internal view returns (uint256) {
            return _length(set._inner);
        }

    /**
        * @dev Returns the value stored at position `index` in the set. O(1).
        *
        * Note that there are no guarantees on the ordering of values inside the
        * array, and it may change when more values are added or removed.
        *
        * Requirements:
        *
        * - `index` must be strictly less than {length}.
        */
        function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
            return _at(set._inner, index);
        }

        // AddressSet

        struct AddressSet {
            Set _inner;
        }

        /**
        * @dev Add a value to a set. O(1).
        *
        * Returns true if the value was added to the set, that is if it was not
        * already present.
        */
        function add(AddressSet storage set, address value) internal returns (bool) {
            return _add(set._inner, bytes32(uint256(uint160(value))));
        }

        /**
        * @dev Removes a value from a set. O(1).
        *
        * Returns true if the value was removed from the set, that is if it was
        * present.
        */
        function remove(AddressSet storage set, address value) internal returns (bool) {
            return _remove(set._inner, bytes32(uint256(uint160(value))));
        }

        /**
        * @dev Returns true if the value is in the set. O(1).
        */
        function contains(AddressSet storage set, address value) internal view returns (bool) {
            return _contains(set._inner, bytes32(uint256(uint160(value))));
        }

        /**
        * @dev Returns the number of values in the set. O(1).
        */
        function length(AddressSet storage set) internal view returns (uint256) {
            return _length(set._inner);
        }

    /**
        * @dev Returns the value stored at position `index` in the set. O(1).
        *
        * Note that there are no guarantees on the ordering of values inside the
        * array, and it may change when more values are added or removed.
        *
        * Requirements:
        *
        * - `index` must be strictly less than {length}.
        */
        function at(AddressSet storage set, uint256 index) internal view returns (address) {
            return address(uint160(uint256(_at(set._inner, index))));
        }


        // UintSet

        struct UintSet {
            Set _inner;
        }

        /**
        * @dev Add a value to a set. O(1).
        *
        * Returns true if the value was added to the set, that is if it was not
        * already present.
        */
        function add(UintSet storage set, uint256 value) internal returns (bool) {
            return _add(set._inner, bytes32(value));
        }

        /**
        * @dev Removes a value from a set. O(1).
        *
        * Returns true if the value was removed from the set, that is if it was
        * present.
        */
        function remove(UintSet storage set, uint256 value) internal returns (bool) {
            return _remove(set._inner, bytes32(value));
        }

        /**
        * @dev Returns true if the value is in the set. O(1).
        */
        function contains(UintSet storage set, uint256 value) internal view returns (bool) {
            return _contains(set._inner, bytes32(value));
        }

        /**
        * @dev Returns the number of values on the set. O(1).
        */
        function length(UintSet storage set) internal view returns (uint256) {
            return _length(set._inner);
        }

    /**
        * @dev Returns the value stored at position `index` in the set. O(1).
        *
        * Note that there are no guarantees on the ordering of values inside the
        * array, and it may change when more values are added or removed.
        *
        * Requirements:
        *
        * - `index` must be strictly less than {length}.
        */
        function at(UintSet storage set, uint256 index) internal view returns (uint256) {
            return uint256(_at(set._inner, index));
        }
    }


    // File @openzeppelin/contracts/utils/ReentrancyGuard.sol@v3.4.2


    pragma solidity >=0.6.0 <0.8.0;

    /**
    * @dev Contract module that helps prevent reentrant calls to a function.
    *
    * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
    * available, which can be applied to functions to make sure there are no nested
    * (reentrant) calls to them.
    *
    * Note that because there is a single `nonReentrant` guard, functions marked as
    * `nonReentrant` may not call one another. This can be worked around by making
    * those functions `private`, and then adding `external` `nonReentrant` entry
    * points to them.
    *
    * TIP: If you would like to learn more about reentrancy and alternative ways
    * to protect against it, check out our blog post
    * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
    */
    abstract contract ReentrancyGuard {
        // Booleans are more expensive than uint256 or any type that takes up a full
        // word because each write operation emits an extra SLOAD to first read the
        // slot's contents, replace the bits taken up by the boolean, and then write
        // back. This is the compiler's defense against contract upgrades and
        // pointer aliasing, and it cannot be disabled.

        // The values being non-zero value makes deployment a bit more expensive,
        // but in exchange the refund on every call to nonReentrant will be lower in
        // amount. Since refunds are capped to a percentage of the total
        // transaction's gas, it is best to keep them low in cases like this one, to
        // increase the likelihood of the full refund coming into effect.
        uint256 private constant _NOT_ENTERED = 1;
        uint256 private constant _ENTERED = 2;

        uint256 private _status;

        constructor () internal {
            _status = _NOT_ENTERED;
        }

        /**
        * @dev Prevents a contract from calling itself, directly or indirectly.
        * Calling a `nonReentrant` function from another `nonReentrant`
        * function is not supported. It is possible to prevent this from happening
        * by making the `nonReentrant` function external, and make it call a
        * `private` function that does the actual work.
        */
        modifier nonReentrant() {
            // On the first call to nonReentrant, _notEntered will be true
            require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

            // Any calls to nonReentrant after this point will fail
            _status = _ENTERED;

            _;

            // By storing the original value once again, a refund is triggered (see
            // https://eips.ethereum.org/EIPS/eip-2200)
            _status = _NOT_ENTERED;
        }
    }


    // File contracts/interfaces/IERC20.sol

    pragma solidity 0.6.12;

    interface IERC20 {
        function totalSupply() external view returns (uint256);

        function balanceOf(address account) external view returns (uint256);

        function allowance(address owner, address spender) external view returns (uint256);

        function approve(address spender, uint256 amount) external returns (bool);

        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);

        // EIP 2612
        function permit(
            address owner,
            address spender,
            uint256 value,
            uint256 deadline,
            uint8 v,
            bytes32 r,
            bytes32 s
        ) external;
    }


    // File contracts/MasterChefAxialV3.sol


    pragma solidity 0.6.12;
    pragma experimental ABIEncoderV2;





    interface IMasterChef {
        struct UserInfo {
            uint256 amount; // How many LP tokens the user has provided.
            uint256 rewardDebt; // Reward debt. See explanation below.
        }

        struct PoolInfo {
            IERC20 lpToken; // Address of LP token contract.
            uint256 allocPoint; // How many allocation points assigned to this pool. AXIAL to distribute per block.
            uint256 lastRewardTimestamp; // Last block number that AXIAL distribution occurs.
            uint256 accAxialPerShare; // Accumulated AXIAL per share, times 1e12. See below.
        }

        function poolInfo(uint256 pid) external view returns (IMasterChef.PoolInfo memory);

        function totalAllocPoint() external view returns (uint256);

        function axialPerSec() external view returns (uint256);

        function deposit(uint256 _pid, uint256 _amount) external;

        function devPercent() external view returns (uint256);

        function treasuryPercent() external view returns (uint256);

        function investorPercent() external view returns (uint256);
    }

    interface IRewarder {
        function onAxialReward(address user, uint256 newLpAmount) external;

        function pendingTokens(address user) external view returns (uint256 pending);

        function rewardToken() external view returns (IERC20);
    }

    library BoringERC20 {
        bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
        bytes4 private constant SIG_NAME = 0x06fdde03; // name()
        bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
        bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)
        bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)

        function returnDataToString(bytes memory data) internal pure returns (string memory) {
            if (data.length >= 64) {
                return abi.decode(data, (string));
            } else if (data.length == 32) {
                uint8 i = 0;
                while (i < 32 && data[i] != 0) {
                    i++;
                }
                bytes memory bytesArray = new bytes(i);
                for (i = 0; i < 32 && data[i] != 0; i++) {
                    bytesArray[i] = data[i];
                }
                return string(bytesArray);
            } else {
                return "???";
            }
        }

        /// @dev Provides a safe ERC20.symbol version which returns '???' as fallback string.
        /// @param token The address of the ERC-20 token contract.
        /// @return (string) Token symbol.
        function safeSymbol(IERC20 token) internal view returns (string memory) {
            (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
            return success ? returnDataToString(data) : "???";
        }

        /// @dev Provides a safe ERC20.name version which returns '???' as fallback string.
        /// @param token The address of the ERC-20 token contract.
        /// @return (string) Token name.
        function safeName(IERC20 token) internal view returns (string memory) {
            (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
            return success ? returnDataToString(data) : "???";
        }

        /// @dev Provides a safe ERC20.decimals version which returns '18' as fallback value.
        /// @param token The address of the ERC-20 token contract.
        /// @return (uint8) Token decimals.
        function safeDecimals(IERC20 token) internal view returns (uint8) {
            (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
            return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
        }

        /// @dev Provides a safe ERC20.transfer version for different ERC-20 implementations.
        /// Reverts on a failed transfer.
        /// @param token The address of the ERC-20 token.
        /// @param to Transfer tokens to.
        /// @param amount The token amount.
        function safeTransfer(
            IERC20 token,
            address to,
            uint256 amount
        ) internal {
            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));
            require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");
        }

        /// @dev Provides a safe ERC20.transferFrom version for different ERC-20 implementations.
        /// Reverts on a failed transfer.
        /// @param token The address of the ERC-20 token.
        /// @param from Transfer tokens from.
        /// @param to Transfer tokens to.
        /// @param amount The token amount.
        function safeTransferFrom(
            IERC20 token,
            address from,
            address to,
            uint256 amount
        ) internal {
            (bool success, bytes memory data) = address(token).call(
                abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount)
            );
            require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");
        }
    }

    /// @dev The (older) MasterChefAxialV2 contract gives out a constant number of AXIAL tokens per block.
    /// It is the only address with minting rights for AXIAL.
    /// The idea for this MasterChefAxialV3 (MCJV3) contract is therefore to be the owner of a dummy token
    /// that is deposited into the MasterChefAxialV2 (MCJV2) contract.
    /// The allocation point for this pool on MCJV3 is the total allocation point for all pools that receive double incentives.
    contract MasterChefAxialV3 is Ownable, ReentrancyGuard {
        using SafeMath for uint256;
        using BoringERC20 for IERC20;
        using EnumerableSet for EnumerableSet.AddressSet;

        /// @dev Info of each MCJV3 user.
        /// `amount` LP token amount the user has provided.
        /// `rewardDebt` The amount of AXIAL entitled to the user.
        struct UserInfo {
            uint256 amount;
            uint256 rewardDebt;
        }

        /// @dev Info of each MCJV3 pool.
        /// `allocPoint` The amount of allocation points assigned to the pool.
        /// Also known as the amount of AXIAL to distribute per block.
        struct PoolInfo {
            IERC20 lpToken;
            uint256 accAxialPerShare;
            uint256 lastRewardTimestamp;
            uint256 allocPoint;
            IRewarder rewarder;
        }

        /// @dev Address of MCJV2 contract.
        IMasterChef public immutable MASTER_CHEF_V2;
        /// @dev Address of AXIAL contract.
        IERC20 public immutable AXIAL;
        /// @dev The index of MCJV3 master pool in MCJV2
        uint256 public immutable MASTER_PID;
        /// @dev Info of each MCJV3 pool.
        PoolInfo[] public poolInfo;
        // Set of all LP tokens that have been added as pools
        EnumerableSet.AddressSet private lpTokens;
        /// @dev Info of each user that stakes LP tokens.
        mapping(uint256 => mapping(address => UserInfo)) public userInfo;
        /// @dev Total allocation points. Must be the sum of all allocation points in all pools.
        uint256 public totalAllocPoint;
        uint256 private constant ACC_TOKEN_PRECISION = 1e18;

        event Add(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IRewarder indexed rewarder);
        event Set(uint256 indexed pid, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);
        event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
        event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
        event UpdatePool(uint256 indexed pid, uint256 lastRewardTimestamp, uint256 lpSupply, uint256 accAxialPerShare);
        event Harvest(address indexed user, uint256 indexed pid, uint256 amount);
        event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);
        event Init();

        /// @param _MASTER_CHEF_V2 The AxialSwap MCJV2 contract address.
        /// @param _axial The AXIAL token contract address.
        /// @param _MASTER_PID The pool ID of the dummy token on the base MCJV2 contract.
        constructor(
            IMasterChef _MASTER_CHEF_V2,
            IERC20 _axial,
            uint256 _MASTER_PID
        ) public {
            MASTER_CHEF_V2 = _MASTER_CHEF_V2;
            AXIAL = _axial;
            MASTER_PID = _MASTER_PID;
        }

        /// @dev Deposits a dummy token to `MASTER_CHEF_V2` MCJV2. This is required because MCJV2 holds the minting rights for AXIAL.
        /// Any balance of transaction sender in `dummyToken` is transferred.
        /// The allocation point for the pool on MCJV2 is the total allocation point for all pools that receive double incentives.
        /// @param dummyToken The address of the ERC-20 token to deposit into MCJV2.
        function init(IERC20 dummyToken) external onlyOwner {
            uint256 balance = dummyToken.balanceOf(msg.sender);
            require(balance != 0, "MasterChefV2: Balance must exceed 0");
            dummyToken.safeTransferFrom(msg.sender, address(this), balance);
            dummyToken.approve(address(MASTER_CHEF_V2), balance);
            MASTER_CHEF_V2.deposit(MASTER_PID, balance);
            emit Init();
        }

        /// @dev Returns the number of MCJV3 pools.
        function poolLength() external view returns (uint256 pools) {
            pools = poolInfo.length;
        }

        /// @dev Add a new LP to the pool. Can only be called by the owner.
        /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.
        /// @param allocPoint AP of the new pool.
        /// @param _lpToken Address of the LP ERC-20 token.
        /// @param _rewarder Address of the rewarder delegate.
        function add(
            uint256 allocPoint,
            IERC20 _lpToken,
            IRewarder _rewarder
        ) external onlyOwner {
            require(!lpTokens.contains(address(_lpToken)), "add: LP already added");
            // Sanity check to ensure _lpToken is an ERC20 token
            _lpToken.balanceOf(address(this));
            // Sanity check if we add a rewarder
            if (address(_rewarder) != address(0)) {
                _rewarder.onAxialReward(address(0), 0);
            }

            uint256 lastRewardTimestamp = block.timestamp;
            totalAllocPoint = totalAllocPoint.add(allocPoint);

            poolInfo.push(
                PoolInfo({
                    lpToken: _lpToken,
                    allocPoint: allocPoint,
                    lastRewardTimestamp: lastRewardTimestamp,
                    accAxialPerShare: 0,
                    rewarder: _rewarder
                })
            );
            lpTokens.add(address(_lpToken));
            emit Add(poolInfo.length.sub(1), allocPoint, _lpToken, _rewarder);
        }

        /// @dev Update the given pool's AXIAL allocation point and `IRewarder` contract. Can only be called by the owner.
        /// @param _pid The index of the pool. See `poolInfo`.
        /// @param _allocPoint New AP of the pool.
        /// @param _rewarder Address of the rewarder delegate.
        /// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.
        function set(
            uint256 _pid,
            uint256 _allocPoint,
            IRewarder _rewarder,
            bool overwrite
        ) external onlyOwner {
            PoolInfo memory pool = poolInfo[_pid];
            totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);
            pool.allocPoint = _allocPoint;
            if (overwrite) {
                _rewarder.onAxialReward(address(0), 0); // sanity check
                pool.rewarder = _rewarder;
            }
            poolInfo[_pid] = pool;
            emit Set(_pid, _allocPoint, overwrite ? _rewarder : pool.rewarder, overwrite);
        }

        /// @dev View function to see pending AXIAL on frontend.
        /// @param _pid The index of the pool. See `poolInfo`.
        /// @param _user Address of user.
        /// @return pendingAxial AXIAL reward for a given user.
        //          bonusTokenAddress The address of the bonus reward.
        //          bonusTokenSymbol The symbol of the bonus token.
        //          pendingBonusToken The amount of bonus rewards pending.
        function pendingTokens(uint256 _pid, address _user)
            external
            view
            returns (
                uint256 pendingAxial,
                address bonusTokenAddress,
                string memory bonusTokenSymbol,
                uint256 pendingBonusToken
            )
        {
            PoolInfo memory pool = poolInfo[_pid];
            UserInfo storage user = userInfo[_pid][_user];
            uint256 accAxialPerShare = pool.accAxialPerShare;
            uint256 lpSupply = pool.lpToken.balanceOf(address(this));
            if (block.timestamp > pool.lastRewardTimestamp && lpSupply != 0) {
                uint256 secondsElapsed = block.timestamp.sub(pool.lastRewardTimestamp);
                uint256 axialReward = secondsElapsed.mul(axialPerSec()).mul(pool.allocPoint).div(totalAllocPoint);
                accAxialPerShare = accAxialPerShare.add(axialReward.mul(ACC_TOKEN_PRECISION).div(lpSupply));
            }
            pendingAxial = user.amount.mul(accAxialPerShare).div(ACC_TOKEN_PRECISION).sub(user.rewardDebt);

            // If it's a double reward farm, we return info about the bonus token
            if (address(pool.rewarder) != address(0)) {
                bonusTokenAddress = address(pool.rewarder.rewardToken());
                bonusTokenSymbol = IERC20(pool.rewarder.rewardToken()).safeSymbol();
                pendingBonusToken = pool.rewarder.pendingTokens(_user);
            }
        }

        /// @dev Update reward variables for all pools. Be careful of gas spending!
        /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.
        function massUpdatePools(uint256[] calldata pids) external {
            uint256 len = pids.length;
            for (uint256 i = 0; i < len; ++i) {
                updatePool(pids[i]);
            }
        }

        /// @dev Calculates and returns the `amount` of AXIAL per block.
        function axialPerSec() public view returns (uint256 amount) {
            uint256 total = 1000;
            uint256 lpPercent = total.sub(MASTER_CHEF_V2.devPercent()).sub(MASTER_CHEF_V2.treasuryPercent()).sub(
                MASTER_CHEF_V2.investorPercent()
            );
            uint256 lpShare = MASTER_CHEF_V2.axialPerSec().mul(lpPercent).div(total);
            amount = lpShare.mul(MASTER_CHEF_V2.poolInfo(MASTER_PID).allocPoint).div(MASTER_CHEF_V2.totalAllocPoint());
        }

        /// @dev Update reward variables of the given pool.
        /// @param pid The index of the pool. See `poolInfo`.
        function updatePool(uint256 pid) public {
            PoolInfo memory pool = poolInfo[pid];
            if (block.timestamp > pool.lastRewardTimestamp) {
                uint256 lpSupply = pool.lpToken.balanceOf(address(this));
                if (lpSupply > 0) {
                    uint256 secondsElapsed = block.timestamp.sub(pool.lastRewardTimestamp);
                    uint256 axialReward = secondsElapsed.mul(axialPerSec()).mul(pool.allocPoint).div(totalAllocPoint);
                    pool.accAxialPerShare = pool.accAxialPerShare.add((axialReward.mul(ACC_TOKEN_PRECISION).div(lpSupply)));
                }
                pool.lastRewardTimestamp = block.timestamp;
                poolInfo[pid] = pool;
                emit UpdatePool(pid, pool.lastRewardTimestamp, lpSupply, pool.accAxialPerShare);
            }
        }

        /// @dev Deposit LP tokens to MCJV3 for AXIAL allocation.
        /// @param pid The index of the pool. See `poolInfo`.
        /// @param amount LP token amount to deposit.
        function deposit(uint256 pid, uint256 amount) external nonReentrant {
            harvestFromMasterChef();
            updatePool(pid);
            PoolInfo memory pool = poolInfo[pid];
            UserInfo storage user = userInfo[pid][msg.sender];

            if (user.amount > 0) {
                // Harvest AXIAL
                uint256 pending = user.amount.mul(pool.accAxialPerShare).div(ACC_TOKEN_PRECISION).sub(user.rewardDebt);
                AXIAL.safeTransfer(msg.sender, pending);
                emit Harvest(msg.sender, pid, pending);
            }

            uint256 balanceBefore = pool.lpToken.balanceOf(address(this));
            pool.lpToken.safeTransferFrom(msg.sender, address(this), amount);
            uint256 receivedAmount = pool.lpToken.balanceOf(address(this)).sub(balanceBefore);

            // Effects
            user.amount = user.amount.add(receivedAmount);
            user.rewardDebt = user.amount.mul(pool.accAxialPerShare).div(ACC_TOKEN_PRECISION);

            // Interactions
            IRewarder _rewarder = pool.rewarder;
            if (address(_rewarder) != address(0)) {
                _rewarder.onAxialReward(msg.sender, user.amount);
            }

            emit Deposit(msg.sender, pid, receivedAmount);
        }

        /// @dev Withdraw LP tokens from MCJV3.
        /// @param pid The index of the pool. See `poolInfo`.
        /// @param amount LP token amount to withdraw.
        function withdraw(uint256 pid, uint256 amount) external nonReentrant {
            harvestFromMasterChef();
            updatePool(pid);
            PoolInfo memory pool = poolInfo[pid];
            UserInfo storage user = userInfo[pid][msg.sender];

            if (user.amount > 0) {
                // Harvest AXIAL
                uint256 pending = user.amount.mul(pool.accAxialPerShare).div(ACC_TOKEN_PRECISION).sub(user.rewardDebt);
                AXIAL.safeTransfer(msg.sender, pending);
                emit Harvest(msg.sender, pid, pending);
            }

            // Effects
            user.amount = user.amount.sub(amount);
            user.rewardDebt = user.amount.mul(pool.accAxialPerShare).div(ACC_TOKEN_PRECISION);

            // Interactions
            IRewarder _rewarder = pool.rewarder;
            if (address(_rewarder) != address(0)) {
                _rewarder.onAxialReward(msg.sender, user.amount);
            }

            pool.lpToken.safeTransfer(msg.sender, amount);

            emit Withdraw(msg.sender, pid, amount);
        }

        /// @dev Harvests AXIAL from `MASTER_CHEF_V2` MCJV2 and pool `MASTER_PID` to this MCJV3 contract.
        function harvestFromMasterChef() public {
            MASTER_CHEF_V2.deposit(MASTER_PID, 0);
        }

        /// @dev Withdraw without caring about rewards. EMERGENCY ONLY.
        /// @param pid The index of the pool. See `poolInfo`.
        function emergencyWithdraw(uint256 pid) external nonReentrant {
            PoolInfo memory pool = poolInfo[pid];
            UserInfo storage user = userInfo[pid][msg.sender];
            uint256 amount = user.amount;
            user.amount = 0;
            user.rewardDebt = 0;

            IRewarder _rewarder = pool.rewarder;
            if (address(_rewarder) != address(0)) {
                _rewarder.onAxialReward(msg.sender, 0);
            }

            // Note: transfer can fail or succeed if `amount` is zero.
            pool.lpToken.safeTransfer(msg.sender, amount);
            emit EmergencyWithdraw(msg.sender, pid, amount);
        }
    }
